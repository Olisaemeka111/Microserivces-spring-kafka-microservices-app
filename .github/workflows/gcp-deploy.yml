name: Deploy to Google Kubernetes Engine

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-deploy:
    name: Build and Deploy to GKE
    runs-on: ubuntu-latest
    env:
      PROJECT_ID: spring-kafka-microservices
      GCP_REGION: us-central1
      GCP_REPOSITORY: microservices
      # GKE Autopilot cluster details
      GKE_CLUSTER: spring-kafka-cluster
      GKE_ZONE: us-central1
      # Note: GCP_SA_KEY must be added as a GitHub secret

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: maven

    - name: Build with Maven
      run: mvn -B package --file pom.xml

    - name: Setup Google Cloud SDK
      uses: google-github-actions/setup-gcloud@v1
      with:
        project_id: ${{ env.PROJECT_ID }}
        service_account_key: ${{ secrets.GCP_SA_KEY }}
        export_default_credentials: true
        
    - name: Get GKE credentials
      uses: google-github-actions/get-gke-credentials@v1
      with:
        cluster_name: ${{ env.GKE_CLUSTER }}
        location: ${{ env.GKE_ZONE }}
        credentials: ${{ secrets.GCP_SA_KEY }}
        
    - name: Set up Kustomize
      run: |
        curl -sfLo kustomize https://github.com/kubernetes-sigs/kustomize/releases/download/v3.1.0/kustomize_3.1.0_linux_amd64
        chmod u+x ./kustomize

    - name: Configure Docker for GCP Artifact Registry
      run: |
        gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev

    - name: Build and Push Docker images
      run: |
        # Build and push order service
        docker build -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.GCP_REPOSITORY }}/order-service:${{ github.sha }} ./order-service
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.GCP_REPOSITORY }}/order-service:${{ github.sha }}
        
        # Build and push inventory service
        docker build -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.GCP_REPOSITORY }}/inventory-service:${{ github.sha }} ./inventory-service
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.GCP_REPOSITORY }}/inventory-service:${{ github.sha }}
        
        # Build and push product service
        docker build -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.GCP_REPOSITORY }}/product-service:${{ github.sha }} ./product-service
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.GCP_REPOSITORY }}/product-service:${{ github.sha }}
        
        # Build and push notification service
        docker build -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.GCP_REPOSITORY }}/notification-service:${{ github.sha }} ./notification-service
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.GCP_REPOSITORY }}/notification-service:${{ github.sha }}

    - name: Create k8s manifests
      run: |
        # Create directory for Kubernetes manifests
        mkdir -p k8s-manifests
        
        # Create deployment and service for Order Service
        cat <<EOF > k8s-manifests/order-service.yaml
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: order-service
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: order-service
          template:
            metadata:
              labels:
                app: order-service
            spec:
              containers:
              - name: order-service
                image: ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.GCP_REPOSITORY }}/order-service:${{ github.sha }}
                ports:
                - containerPort: 8080
                resources:
                  requests:
                    cpu: "100m"
                    memory: "512Mi"
                  limits:
                    cpu: "500m"
                    memory: "1Gi"
                env:
                - name: SPRING_PROFILES_ACTIVE
                  value: "prod"
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: order-service
        spec:
          selector:
            app: order-service
          ports:
          - port: 80
            targetPort: 8080
          type: ClusterIP
        EOF
        
        # Create deployment and service for Inventory Service
        cat <<EOF > k8s-manifests/inventory-service.yaml
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: inventory-service
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: inventory-service
          template:
            metadata:
              labels:
                app: inventory-service
            spec:
              containers:
              - name: inventory-service
                image: ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.GCP_REPOSITORY }}/inventory-service:${{ github.sha }}
                ports:
                - containerPort: 8080
                resources:
                  requests:
                    cpu: "100m"
                    memory: "512Mi"
                  limits:
                    cpu: "500m"
                    memory: "1Gi"
                env:
                - name: SPRING_PROFILES_ACTIVE
                  value: "prod"
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: inventory-service
        spec:
          selector:
            app: inventory-service
          ports:
          - port: 80
            targetPort: 8080
          type: ClusterIP
        EOF
        
        # Create deployment and service for Product Service
        cat <<EOF > k8s-manifests/product-service.yaml
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: product-service
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: product-service
          template:
            metadata:
              labels:
                app: product-service
            spec:
              containers:
              - name: product-service
                image: ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.GCP_REPOSITORY }}/product-service:${{ github.sha }}
                ports:
                - containerPort: 8080
                resources:
                  requests:
                    cpu: "100m"
                    memory: "512Mi"
                  limits:
                    cpu: "500m"
                    memory: "1Gi"
                env:
                - name: SPRING_PROFILES_ACTIVE
                  value: "prod"
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: product-service
        spec:
          selector:
            app: product-service
          ports:
          - port: 80
            targetPort: 8080
          type: ClusterIP
        EOF
        
        # Create deployment and service for Notification Service
        cat <<EOF > k8s-manifests/notification-service.yaml
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: notification-service
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: notification-service
          template:
            metadata:
              labels:
                app: notification-service
            spec:
              containers:
              - name: notification-service
                image: ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.GCP_REPOSITORY }}/notification-service:${{ github.sha }}
                ports:
                - containerPort: 8080
                resources:
                  requests:
                    cpu: "100m"
                    memory: "512Mi"
                  limits:
                    cpu: "500m"
                    memory: "1Gi"
                env:
                - name: SPRING_PROFILES_ACTIVE
                  value: "prod"
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: notification-service
        spec:
          selector:
            app: notification-service
          ports:
          - port: 80
            targetPort: 8080
          type: ClusterIP
        EOF
        
        # Create Ingress for external access
        cat <<EOF > k8s-manifests/ingress.yaml
        apiVersion: networking.k8s.io/v1
        kind: Ingress
        metadata:
          name: microservices-ingress
          annotations:
            kubernetes.io/ingress.class: "gce"
        spec:
          rules:
          - http:
              paths:
              - path: /api/order
                pathType: Prefix
                backend:
                  service:
                    name: order-service
                    port:
                      number: 80
              - path: /api/inventory
                pathType: Prefix
                backend:
                  service:
                    name: inventory-service
                    port:
                      number: 80
              - path: /api/product
                pathType: Prefix
                backend:
                  service:
                    name: product-service
                    port:
                      number: 80
              - path: /api/notification
                pathType: Prefix
                backend:
                  service:
                    name: notification-service
                    port:
                      number: 80
        EOF
    
    - name: Deploy to GKE
      run: |
        # Apply Kubernetes manifests
        kubectl apply -f k8s-manifests/
        
        # Wait for deployments to be ready (with longer timeout for Autopilot)
        kubectl rollout status deployment/order-service --timeout=5m
        kubectl rollout status deployment/inventory-service --timeout=5m
        kubectl rollout status deployment/product-service --timeout=5m
        kubectl rollout status deployment/notification-service --timeout=5m
        
        # Get the Ingress IP (this may take several minutes in Autopilot)
        echo "Waiting for Ingress to get an external IP..."
        echo "Note: This may take 5-10 minutes in GKE Autopilot"
        
        # Print service and ingress information
        kubectl get services
        kubectl get ingress microservices-ingress
        
        # Get the actual ingress IP when available
        kubectl get ingress microservices-ingress --output jsonpath='{.status.loadBalancer.ingress[0].ip}'
